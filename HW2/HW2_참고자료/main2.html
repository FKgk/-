<!doctype html>
<html lang="ko">
<head>
	<meta charset="utf-8" />
	<title>Direct Manipulation of Math Symbols</title>
</head>
<body>
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js' type='text/javascript'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/2.4.6/fabric.min.js" type="text/javascript"></script>
    <script src="math.min.js" type="text/javascript"></script>

    <canvas id="c" width="1024" height="768">
        Canvas not supported
    </canvas>

    <script>
        const parser = math.parser();

        const SYMBOL_WIDTH = 50;
        const SYMBOL_HEIGHT = 50;

        let MathApp = {};

        MathApp.symbol_paths = {
                '+':    "add",
                '-':    "sub",
                '*':    "mul",
                '/':    "div",
                '(':    "parenthesis_open",
                ')':    "parenthesis_close",
                '[':    "squarebracket_open",
                ']':    "squarebracket_close",
                '{':    "curlybrace_open",
                '}':    "curlybrace_close",
                '.':    "period",
                ',':    "comma",
                ':':    "colon",
                ';':    "semicolon",
                '=':    "equal",
                '>':    "more",
                '<':    "less",
                '!':    "exclamation",
                "delete" : "delete",
                "start" : "start",
                "separate" : "separate",
                "copy" : "copy"
        };

        MathApp.blocks = [];
        MathApp.selected_block = null;

        MathApp.is_mouse_dragging = false;       
        MathApp.mouse_drag_prev = {x:0, y:0};

        MathApp.block_types = {
            UNDEFINED:  "undefind",
            SYMBOL:     "symbol",
        };

        MathApp.popup_list = [ "delete", "start", "separate", "copy" ];
        MathApp.popup_block_list = [];

        MathApp.initialize = function() {
            for(let i=0; i <= 9; i++)
            {
                let key = i.toString();
                let value = key;
                this.symbol_paths[key] = value;
            }

            for(let c="a".charCodeAt(0); c <= "z".charCodeAt(0); c++)
            {
                let key = String.fromCharCode(c);
                let value = key;
                this.symbol_paths[key] = value;
            }

            this.canvas = new fabric.Canvas("c", {
                backgroundColor: "#eee",
                hoverCursor: "default",
                selection: false
            });

            //
            $(document).keypress(function(event) {
                let key = String.fromCharCode(event.which);
                MathApp.handleKeyPress(key);
            });
            $(document).mousedown(function(event) {
                let p = {x: event.pageX, y: event.pageY};
                MathApp.handleMouseDown(p);
            });
            $(document).mouseup(function(event) {
                let p = {x: event.pageX, y: event.pageY};
                MathApp.handleMouseUp(p);
            });
            $(document).mousemove(function(event) {
                let p = {x: event.pageX, y: event.pageY};
                MathApp.handleMouseMove(p);
            });
        }

        MathApp.handleKeyPress = function(key) {
            if (key in this.symbol_paths) 
            {
                let size = {
                    width : SYMBOL_WIDTH,
                    height : SYMBOL_HEIGHT
                };
                let position = {
                    x : Math.random() * (this.canvas.width-size.width) + size.width/2,
                    y : Math.random() * (this.canvas.height-size.height) + size.height/2
                };

                let new_symbol = new MathApp.Symbol(position, size, key);
                return new_symbol
            }
        }

        MathApp.handleMouseDown = function(window_p) {
            if(MathApp.isInCanvas(window_p))
            {
                let canvas_p = MathApp.transformToCanvasCoords(window_p);
                let preSelected_block = null;

                if (MathApp.selected_block != null) {
                    preSelected_block = MathApp.selected_block;

                    MathApp.selected_block.onDeselected();
                    MathApp.selected_block = null;
                }

                let block = MathApp.findBlockOn(canvas_p);
                if (block != null) 
                {
                    if (MathApp.popup_list.includes(block.name)) 
                    {
                        if (preSelected_block != null) 
                        {
                            MathApp.deletePopup();
                            MathApp.selectPopup(preSelected_block, block);
                            console.log("selectPopup END");
                        }
                    }
                    else
                    {
                        MathApp.deletePopup();
                        MathApp.createPopup(block);
                        MathApp.selected_block = block;
                        MathApp.selected_block.onSelected();
                    }
                    console.log(block);
                }
                else
                {
                    MathApp.deletePopup();
                }
                MathApp.is_mouse_dragging = true;
                MathApp.mouse_drag_prev = canvas_p;

                MathApp.canvas.requestRenderAll();
            }
            else 
            {
                MathApp.deletePopup();
                MathApp.is_mouse_dragging = false;
                MathApp.mouse_drag_prev = { x: 0, y: 0 };
            }

        }

        MathApp.createPopup = function(block)
        {
            if (block == null)
                return null;
            
            for(let i = 0; i < MathApp.popup_list.length; i++)
            {
                let size = {
                    width: 20,
                    height: 20
                };
                let position = {
                    x: block.position.x - block.size.width / 2  + i * 22,
                    y: block.position.y + block.size.height
                };

                let new_symbol = new MathApp.Symbol(position, size, MathApp.popup_list[i]);
                MathApp.popup_block_list.push(new_symbol);
                //new_symbol.visual_items.splice(new_symbol.visual_items.length - 1, 1);
            }

            MathApp.canvas.requestRenderAll();
        }
        
        MathApp.selectPopup = async function (selected_block, block)
        {
            if(selected_block == null || block == null)
                return null;

            if(block.name == "start")
            {
                let result = String(parser.eval(selected_block.name));
                let blocks = [];
                let size = {
                    width: SYMBOL_WIDTH,
                    height: SYMBOL_HEIGHT
                };
                let position = {
                    x: selected_block.position.x,
                    y: selected_block.position.y + selected_block.size.height + 10
                };

                console.log(position);
                console.log(size);

                let mainBlock = new MathApp.Symbol(position, size, result[0]);
                mainBlock.name = result;

                console.log("mainBlock1");
                console.log(mainBlock);
                for (let i = 1; i < result.length; i++)
                {
                    let tempPosition = {x : position.x + 50 * i,
                                        y : position.y};

                    console.log("i : ",i, "position : ",tempPosition);
                    MathApp.create_visual_blocks(mainBlock, tempPosition, size, result[i]);
                }
                mainBlock.visual_items[mainBlock.visual_items.length - 1].width += MathApp.SYMBOL_WIDTH * (result.length - 1);
                mainBlock.position.x += (MathApp.SYMBOL_WIDTH) / 2 * (result.length - 1);
                mainBlock.size.width += MathApp.SYMBOL_WIDTH * (result.length - 1);
                console.log(mainBlock);


                MathApp.canvas.requestRenderAll();

            }
            else if(block.name == "delete")
            {
                console.log("select popup delete");

                MathApp.deletePopup();
                selected_block.destroy();
            }
            else if(block.name == "copy")
            {
                console.log("select popup copy");

                //MathApp.blocks.push(selected_block);
            }
            else if(block.name == "separate")
            {
                console.log("select popup separate");

            }
            else
            {
                console.log("ERRRROR");
                console.log(block.name);
                console.log("ERRRROR");
            }

            MathApp.canvas.requestRenderAll();
        }
        
        MathApp.deletePopup = function()
        {
            for(let i = MathApp.blocks.length - 1; i >= 0 ; i--)
            {
                if(MathApp.popup_list.includes(MathApp.blocks[i].name))
                {
                    MathApp.blocks[i].destroy();
                }
            }
            
            MathApp.popup_block_list = [];

            MathApp.canvas.requestRenderAll();
        }

        MathApp.handleMouseMove = function(window_p) {
            if(MathApp.is_mouse_dragging)
            {
                let canvas_p = MathApp.transformToCanvasCoords(window_p);
                if(MathApp.selected_block != null)
                {
                    let tx = canvas_p.x - MathApp.mouse_drag_prev.x;
                    let ty = canvas_p.y - MathApp.mouse_drag_prev.y;
                    MathApp.selected_block.translate({x: tx, y: ty});
// popup이 selected_block과 함께 이동한다.
                    for (let i = 0; i < 4; i++)
                    {
                        MathApp.popup_block_list[i].translate({x: tx, y:ty});
                    }
// 완료
                }
                MathApp.mouse_drag_prev = canvas_p;

                MathApp.canvas.requestRenderAll();
            }
        }

        MathApp.handleMouseUp = function(window_p) {
            if(MathApp.is_mouse_dragging)
            {
                let canvas_p = MathApp.transformToCanvasCoords(window_p);

                MathApp.is_mouse_dragging = false;
                MathApp.mouse_drag_prev = {x:0, y:0};

//여기가 합치는 자리 예상
                let block = MathApp.assemble(MathApp.findOverlapBlock(canvas_p, MathApp.selected_block), MathApp.selected_block)

                if(block != null)
                {
                    let p = { x: block.position.x, y: block.position.y };
                    MathApp.handleMouseDown(p);
                    MathApp.is_mouse_dragging = false;
                }
//여기가 합치기 끝

                MathApp.canvas.requestRenderAll();
            }
        }

// 합치는 함수
        MathApp.assemble = function(block, selected_block){
            if (selected_block == null || block == null || MathApp.popup_list.includes(block.name) )
                return null;

            if(MathApp.selected_block != null)
            {
                MathApp.selected_block.onDeselected();
                MathApp.selected_block = null;
            }
            let block_last_item = block.visual_items[block.visual_items.length - 1];
            if(block.visual_items.length > 3)
            {
                block.visual_items[block.visual_items.length - 1].left = block.visual_items[2].left + SYMBOL_WIDTH * (block.name.length - 1);

                block.visual_items[block.visual_items.length - 1].width = SYMBOL_WIDTH;
            }

            for (let i = 0; i < selected_block.visual_items.length; i++) 
            {
                selected_block.visual_items[i].left = block.visual_items[i].left + block.size.width;
                selected_block.visual_items[i].top = block.visual_items[i].top;
                block.visual_items.push(selected_block.visual_items[i]);
            }
            
            block.visual_items[block.visual_items.length - 1].left = block.visual_items[2].left;        
            block.visual_items[block.visual_items.length - 1].width = block.size.width + selected_block.size.width;
            
            block.position.x += selected_block.size.width / 2;
            block.size.width += selected_block.size.width;
            block.name += selected_block.name;

            selected_block.destroy();

            MathApp.canvas.requestRenderAll();

            return block;
        }
// 합치는 함수 완료

        MathApp.transformToCanvasCoords = function(window_p) {
            let rect = MathApp.canvas.getElement().getBoundingClientRect();
            let canvas_p = {
                x : window_p.x - rect.left,
                y : window_p.y - rect.top
            };
            return canvas_p;
        }
        
        MathApp.isInCanvas = function(window_p) {
            let rect = MathApp.canvas.getElement().getBoundingClientRect();
            if( window_p.x >= rect.left && 
                window_p.x < rect.left + rect.width &&
                window_p.y >= rect.top && 
                window_p.y < rect.top + rect.height )
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        MathApp.findBlockOn = function(canvas_p) {
            let x = canvas_p.x;
            let y = canvas_p.y;

            for(let i=0; i < this.blocks.length; i++)
            {
                let block = this.blocks[i];

                if( x >= block.position.x - block.size.width/2 &&
                    x <= block.position.x + block.size.width/2 &&
                    y >= block.position.y - block.size.height/2 &&
                    y <= block.position.y + block.size.height/2 )
                {
                    return block;
                }               
            }
            return null;
        }

// 겹치는 부분 찾기
        MathApp.findOverlapBlock = function (canvas_p, selected_block) {
            if (selected_block != null) {
                let x = selected_block.position.x;
                let y = selected_block.position.y;

                for (let i = 0; i < this.blocks.length; i++) {
                    let block = this.blocks[i];

                    if (block != selected_block) {
                        if (Math.abs(x - block.position.x) <= (block.size.width + selected_block.size.width) / 2 &&
                            Math.abs(y - block.position.y) <= (block.size.height + selected_block.size.height) / 2) {
                            return block;
                        }
                    }
                }
            }

            return null;
        }
// 겹치는 부분 찾기 완료

        MathApp.Block = function(position, size) {
            this.position = position;
            this.size = size;
            this.type = MathApp.block_types.UNDEFINED;

            this.visual_items = [];
            MathApp.blocks.push(this);
        }

        MathApp.Block.prototype.onDeselected = function() {
            this.visual_items[this.visual_items.length-1].set({
                stroke: "rgba(0,0,255,1)"
            });
        }

        MathApp.Block.prototype.onSelected = function() {
            this.visual_items[this.visual_items.length-1].set({
                stroke: "rgba(255,0,0,1)"
            });

            this.visual_items.forEach(item => {
                MathApp.canvas.bringToFront(item);
            });
        }

        MathApp.Block.prototype.moveTo = function(p) {
            let tx = p.x - this.position.x;
            let ty = p.y - this.position.y;

            this.translate({x: tx, y: ty});
        }

        MathApp.Block.prototype.translate = function(v) {
            this.position.x += v.x;
            this.position.y += v.y;

            this.visual_items.forEach(item => {
                item.left += v.x;
                item.top += v.y;
            });
        }

        MathApp.Block.prototype.destroy = function() {
            if(this == MathApp.selected_block)
            {
                MathApp.selected_block = null;
                this.onDeselected();
            }

            this.visual_items.forEach(item => {
                MathApp.canvas.remove(item);
            });
            this.visual_items = [];
            
            let index = MathApp.blocks.indexOf(this);
            if(index > -1)
            {
                MathApp.blocks.splice(index, 1);
            }
        }

        //
        MathApp.Symbol = function(position, size, name) {
            MathApp.Block.call(this, position, size);
            this.type = MathApp.block_types.SYMBOL;
            this.name = name;

            let block = this;

            if (name in MathApp.symbol_paths) 
            {
                let path = MathApp.symbol_paths[name] + ".jpg";
                fabric.Image.fromURL(path, function(img) {
                    // (0) Background
                    let background = new fabric.Rect({
                        left: position.x - size.width/2,
                        top: position.y - size.height/2,
                        width: size.width,
                        height: size.height,
                        fill: "rgba(255,255,255,1)",
                        stroke: "rgba(0,0,0,0)",
                        selectable: false
                    });

                    // (1) Image
                    img.scaleToWidth(size.width);
                    img.scaleToHeight(size.height);

                    let img_w = img.getScaledWidth();
                    let img_h = img.getScaledHeight();

                    img.set({
                        left: position.x - img_w/2,
                        top: position.y - img_h/2,
                        selectable: false
                    });

                    // (2) Boundary
                    let boundary = new fabric.Rect({
                        left: position.x - size.width/2,
                        top: position.y - size.height/2,
                        width: size.width,
                        height: size.height,
                        fill: "rgba(0,0,0,0)",
                        stroke: "rgba(0,0,255,1)",
                        strokeWidth: 5,
                        selectable: false
                    });

                    MathApp.canvas.add(background);
                    MathApp.canvas.add(img);
                    MathApp.canvas.add(boundary);

                    block.visual_items.push(background);
                    block.visual_items.push(img);
                    block.visual_items.push(boundary);
                });
            }
            return block;
        }

         MathApp.createBlock = function(position, size, name)
         {
             for(let i = name.length - 1; i >= 0 ; i--)
             {
                new MathApp.Symbol(position, size, name[i]);
             }
         }

        MathApp.Symbol.prototype = Object.create(MathApp.Block.prototype);
        
        MathApp.create_visual_blocks = function(block, position, size, name)
        {
            console.log("create visual block");
            console.log("position : ",position);
            let path = MathApp.symbol_paths[name] + ".jpg";
            fabric.Image.fromURL(path, function (img) 
            {
                // (0) Background
                let background = new fabric.Rect({
                    left: position.x - size.width / 2,
                    top: position.y - size.height / 2,
                    width: size.width,
                    height: size.height,
                    fill: "rgba(255,255,255,1)",
                    stroke: "rgba(0,0,0,0)",
                    selectable: false
                });

                 // (1) Image
                img.scaleToWidth(size.width);
                img.scaleToHeight(size.height);

                let img_w = img.getScaledWidth();
                let img_h = img.getScaledHeight();

                img.set({
                    left: position.x - img_w / 2,
                    top: position.y - img_h / 2,
                    selectable: false
                });

                // (2) Boundary
                let boundary = new fabric.Rect({
                    left: position.x - size.width / 2,
                    top: position.y - size.height / 2,
                    width: size.width,
                    height: size.height,
                    fill: "rgba(0,0,0,0)",
                    stroke: "rgba(0,0,255,1)",
                    strokeWidth: 5,
                    selectable: false
                });

                MathApp.canvas.add(background);
                MathApp.canvas.add(img);
                MathApp.canvas.add(boundary);

                block.visual_items.push(background);
                block.visual_items.push(img);
                block.visual_items.push(boundary);
            });
        }

        //
        $(document).ready(function() {
            MathApp.initialize();
        });
    </script>
    
</body>
</html>

